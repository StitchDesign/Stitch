//
//  PatchEvaluateExtensions.swift
//  Stitch
//
//  Created by Christian J Clampitt on 7/12/22.
//

import Foundation
import SwiftUI
import StitchSchemaKit

extension Patch {
    @MainActor
    var evaluate: EvaluationStyle {
        switch self {
        case
            // wireless nodes are just splitter nodes with covered up edges and invisible edges
            .wirelessReceiver, .wirelessBroadcaster:
            return .pure(.node(outputsOnlyEval(identityEvaluation)))
        case .splitter:
            // .impure(.impure because of pulse nodeType)
            return .impure(.graphStep(splitterEval))
        case .imageImport:
            return .pure(.node(imageImportEval))
        case .add:
            return .pure(.node(arithmeticNodeTypeEval(addEval)))
        case .convertPosition:
            return .pure(.graph(outputsOnlyGraphStateEval(convertPositionEval)))
        case .multiply:
            return .pure(.node(mathNodeTypeEval(multiplyEval)))
        case .divide:
            return .pure(.node(mathNodeTypeEval(divideEval)))
        // Scroll interaction is a little different because scroll does animation stuff
        case .pressInteraction:
            // DOES NOT USE graph step
            return .impure(.graphAndGraphStep(pressInteractionEval))
        case .dragInteraction:
            // DOES use GraphStep
            return .impure(.graphAndGraphStep(dragInteractionEval))
        case .cameraFeed:
            return .impure(.graph(cameraFeedEval))
        case .loop:
            return .pure(.node(outputsOnlyEval(loopStartEval)))
        case .counter:
            return .impure(.graphStep(counterEval))
        case .repeatingPulse:
            return .impure(.graph(repeatingPulseEval))
        //        case .soundKit:
        //            // technically has no outputs and is side-effect only...
        //            return .impure(.computed(soundKitEval))
        case .time:
            return .pure(.graphStep(timeEvalWrapper))
        case .deviceTime:
            return .pure(.node(deviceTimeEval))
        case .location:
            return .impure(.graph(locationEval))
        case .random:
            return .impure(.graphStep(randomEval))
        case .hslColor:
            return .pure(.node(outputsOnlyEval(hslColorEval)))
        case .optionPicker:
            return .pure(.node(outputsOnlyEval(optionPickerEval)))
        case .pack:
            return .pure(.node(outputsOnlyEval(packEval)))
        case .unpack:
            return .pure(.node(outputsOnlyEval(unpackEval)))
        case .or:
            return .pure(.node(outputsOnlyEval(orEval)))
        case .and:
            return .pure(.node(outputsOnlyEval(andEval)))
        case .restartPrototype:
            return .impure(.graphStep(restartPrototypeEval))
        case .flipSwitch:
            return .impure(.graphStep(switchEval))
        case .optionSwitch:
            return .impure(.graphStep(optionSwitchEval))
        case .pulseOnChange:
            return .impure(.graphStep(pulseOnChangeEval))
        case .pulse:
            return .impure(.graphStep(pulseNodeEval))
        case .springAnimation:
            return .impure(.graphStep(springAnimationEval))
        case .popAnimation:
            return .impure(.graphStep(popAnimationEval))
        case .bouncyConverter:
            return .pure(.node(outputsOnlyEval(bouncyConverterEval)))
        case .classicAnimation:
            return .impure(.graphStep(classicAnimationEval))
        case .curve:
            return .pure(.node(outputsOnlyEval(curveEval)))
        case .cubicBezierAnimation:
            return .impure(.graphStep(cubicBezierAnimationEval))
        case .cubicBezierCurve:
            return .pure(.node(outputsOnlyEval(cubicBezierCurveEval)))
        case .repeatingAnimation:
            return .impure(.graphStep(repeatingAnimationEval))
        case .loopBuilder:
            return .impure(.graphStep(loopBuilderEval))
        case .loopInsert:
            return .impure(.graphStep(loopInsertEval))
        case .delay:
            return .pure(.node(delayEval))
        case .coreMLClassify:
            return .pure(.node(coreMLClassifyEval))
        case .coreMLDetection:
            return .pure(.node(coreMLDetectionEval))
        case .not:
            return .pure(.node(outputsOnlyEval(notEval)))
        case .transition:
            return .pure(.node(outputsOnlyEval(transitionEval)))
        case .scrollInteraction:
            return .impure(.graphAndGraphStep(scrollInteractionEval))
        case .sampleAndHold:
            return .impure(.graphStep(sampleAndHoldEval))
        case .grayscale:
            return .pure(.node(grayscaleEval))
        case .loopSelect:
            return .pure(.node(outputsOnlyEval(loopSelectEval)))
        case .videoImport:
            return .pure(.node(videoImportEval))
        case .sampleRange:
            return .impure(.graphAndGraphStep(sampleRangeEval))
        case .soundImport:
            return .pure(.node(soundImportEval))
        case .speaker:
            return .pure(.node(speakerEval))
        case .microphone:
            return .pure(.node(microphoneEval))
        case .networkRequest:
            return .impure(.graphStep(networkRequestEval))
        case .valueForKey:
            return .pure(.graphStep(valueForKeyEval))
        case .valueAtIndex:
            return .pure(.graphStep((valueAtIndexEval)))
        case .loopOverArray:
            return .pure(.node(outputsOnlyEval(loopOverArrayEval)))
        case .setValueForKey:
            return .pure(.node(setValueForKeyEval))
        case .jsonObject:
            return .pure(.node(jsonObjectEval))
        case .jsonArray:
            return .pure(.node(jsonArrayEval))
        case .arrayAppend:
            return .pure(.node(arrayAppendEval))
        case .arrayCount:
            return .pure(.node(outputsOnlyEval(arrayCountEval)))
        case . arrayJoin:
            return .pure(.node(outputsOnlyEval(arrayJoinEval)))
        case .arrayReverse:
            return .pure(.node(outputsOnlyEval(arrayReverseEval)))
        case .arraySort:
            return .pure(.node(outputsOnlyEval(arraySortEval)))
        case .getKeys:
            return .pure(.node(outputsOnlyEval(getKeysEval)))
        case .indexOf:
            return .pure(.node(outputsOnlyEval(indexOfEval)))
        case .subarray:
            return .pure(.node(outputsOnlyEval(subarrayEval)))
        case . valueAtPath:
            return .pure(.graphStep(valueAtPathEval))
        case .deviceMotion:
            return .pure(.graph(deviceMotionEval))
        case .deviceInfo:
            return .pure(.graph(deviceInfoEval))
        case .velocity:
            return .pure(.node(velocityEval))
        case .smoothValue:
            return .impure(.graphStep(smoothValueEval))
        case .clip:
            return .pure(.node(outputsOnlyEval(clipEval)))
        case .max:
            return .pure(.node(outputsOnlyEval(maxEval)))
        case .mod:
            return .pure(.node(outputsOnlyEval(modEval)))
        case .round:
            return .pure(.node(outputsOnlyEval(roundEval)))
        case .absoluteValue:
            return .pure(.node(outputsOnlyEval(absoluteValueEval)))
        case .progress:
            return .pure(.node(outputsOnlyEval(progressEval)))
        case .reverseProgress:
            return .pure(.node(outputsOnlyEval(reverseProgressEval)))
        case .rgba:
            return .pure(.node(outputsOnlyEval(rgbaEval)))
        case .arcTan2:
            return .pure(.node(outputsOnlyEval(arcTan2Eval)))
        case .sine:
            return .pure(.node(outputsOnlyEval(sineEval)))
        case .cosine:
            return .pure(.node(outputsOnlyEval(cosineEval)))
        case .hapticFeedback:
            return .impure(.graphStep(hapticFeedbackEval))
        case .imageToBase64String:
            return .pure(.node(imageToBase64StringEval))
        case .base64StringToImage:
            return .pure(.node(base64StringToImageEval))
        case .whenPrototypeStarts:
            return  .impure(.graphStep(whenPrototypeStartsEval))
        case .soulver:
            return .pure(.node(outputsOnlyEval(soulverEval)))
        case .optionEquals:
            return .pure(.node(outputsOnlyEval(optionEqualsEval)))
        case .subtract:
            return .pure(.node(arithmeticNodeTypeEval(subtractEval)))
        case .squareRoot:
            return .pure(.node(arithmeticNodeTypeEval(squareRootEval)))
        case .length:
            return .pure(.node(arithmeticNodeTypeEval(lengthEval)))
        case .min:
            return .pure(.node(outputsOnlyEval(minEval)))
        case .power:
            return .pure(.node(arithmeticNodeTypeEval(powerEval)))
        case .equals:
            return .pure(.node(outputsOnlyEval(equalsEval)))
        case .equalsExactly:
            return .pure(.node(pureNodeEval(equalsExactlyEval)))
        case .greaterThan:
            return .pure(.node(pureNodeEval(greaterThanEval)))
        case .greaterOrEqual:
            return.pure(.node(pureNodeEval(greaterOrEqualEval)))
        case .lessThan:
            return .pure(.node(pureNodeEval(lessThanEval)))
        case .lessThanOrEqual:
            return .pure(.node(pureNodeEval(lessThanOrEqualEval)))
        case .colorToHSL:
            return .pure(.node(outputsOnlyEval(colorToHSLEval)))
        case .colorToHex:
            return .pure(.node(outputsOnlyEval(colorToHexEval)))
        case .colorToRGB:
            return .pure(.node(outputsOnlyEval(colorToRGBAEval)))
        case .hexColor:
            return .pure(.node(outputsOnlyEval(hexEval)))
        case .splitText:
            return .pure(.node(outputsOnlyEval(splitTextEval)))
        case .textEndsWith:
            return .pure(.node(outputsOnlyEval(textEndsWithEval)))
        case .textLength:
            return .pure(.node(outputsOnlyEval(textLengthEval)))
        case .textReplace:
            return .pure(.node(outputsOnlyEval(textReplaceEval)))
        case .textStartsWith:
            return .pure(.node(outputsOnlyEval(textStartsWithEval)))
        case .trimText:
            return .pure(.node(outputsOnlyEval(trimTextEval)))
        case .textTransform:
            return .pure(.node(outputsOnlyEval(textTransformEval)))
        case .dateAndTimeFormatter:
            return .pure(.node(outputsOnlyEval(dateAndTimeFormatterEval)))
        case .stopwatch:
            return .pure(.graphStep(stopwatchEval))
        case .optionSender:
            return .pure(.node(outputsOnlyEval(optionSenderEval)))
        case .any:
            return .pure(.node(outputsOnlyEval(anyEval)))
        case .loopCount:
            return .pure(.node(outputsOnlyEval(loopCountEval)))
        case .loopDedupe:
            return .pure(.node(outputsOnlyEval(loopDedupeEval)))
        case .loopOptionSwitch:
            return .impure(.graphStep(loopOptionSwitchEval))
        case .loopRemove:
            return .pure(.graphStep(loopRemoveEval))
        case .loopReverse:
            return .pure(.node(outputsOnlyEval(loopReverseEval)))
        case .loopShuffle:
            return .pure(.graphStep(loopShuffleEval))
        case .loopSum:
            return .pure(.node(outputsOnlyEval(loopSumEval)))
        case .loopToArray:
            return .pure(.node(loopToArrayEval))
        case .runningTotal:
            return .pure(.node(outputsOnlyEval(runningTotalEval)))
        case .loopFilter:
            return .pure(.node(outputsOnlyEval(loopFilterEval)))
        case .layerInfo:
            return .pure(.graph(layerInfoEval))
        case .triangleShape:
            return .pure(.node(outputsOnlyEval(triangleShapeEval)))
        case .ovalShape:
            return .pure(.node(outputsOnlyEval(ovalShapeEval)))
        case .circleShape:
            return .pure(.node(outputsOnlyEval(circleShapeEval)))
        case .roundedRectangleShape:
            return .pure(.node(outputsOnlyEval(roundedRectangleShapeEval)))
        case .union:
            return .pure(.node(outputsOnlyEval(unionEval)))
        case .model3DImport:
            return .pure(.node(model3DImportEval))
        case .arRaycasting:
            return .pure(.node(arRayCastingEval))
        case .keyboard:
            return .pure(.graph(keyboardEval))
        case .jsonToShape:
            return .pure(.node(outputsOnlyEval(jsonToShapeEval)))
        case .arAnchor:
            return .pure(.node(arAnchorEval))
        case .shapeToCommands:
            return .pure(.node(outputsOnlyEval(shapeToCommandsEval)))
        case .commandsToShape:
            return .pure(.node(outputsOnlyEval(commandsToShapeEval)))
        case .mouse:
            return .pure(.node(outputsOnlyEval(mouseEval)))
        case .sizePack:
            return .pure(.node(outputsOnlyEval(sizePackEval)))
        case .sizeUnpack:
            return .pure(.node(outputsOnlyEval(sizeUnpackEval)))
        case .positionPack:
            return .pure(.node(outputsOnlyEval(positionPackEval)))
        case .positionUnpack:
            return .pure(.node(outputsOnlyEval(positionUnpackEval)))
        case .point3DPack:
            return .pure(.node(outputsOnlyEval(point3DPackEval)))
        case .point3DUnpack:
            return .pure(.node(outputsOnlyEval(point3DUnpackEval)))
        case .point4DPack:
            return .pure(.node(outputsOnlyEval(point4DPackEval)))
        case .point4DUnpack:
            return .pure(.node(outputsOnlyEval(point4DUnpackEval)))
        case .matrixTransformPack:
            return .pure(.node(outputsOnlyEval(matrixTransformPackEval)))
        case .matrixTransformUnpack:
            return .pure(.node(outputsOnlyEval(matrixTransformUnpackEval)))
        case .closePath:
            return .pure(.node(outputsOnlyEval(identityEvaluation)))
        case .moveToPack:
            return .pure(.node(outputsOnlyEval(moveToPackEval)))
        case .lineToPack:
            return .pure(.node(outputsOnlyEval(lineToPackEval)))
        case .curveToPack:
            return .pure(.node(outputsOnlyEval(curveToPackEval)))
        case .curveToUnpack:
            return .pure(.node(outputsOnlyEval(curveToUnpackEval)))
        case .mathExpression:
            return .pure(.node(mathExpressionEval))
        case .qrCodeDetection:
            return .pure(.node(qrCodeDetectionEval))
        }
    }
}
